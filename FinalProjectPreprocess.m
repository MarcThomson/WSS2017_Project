(* ::Package:: *)

(* ::Title:: *)
(*Predicting Chemical Properties From Structure*)


(* ::Section::Closed:: *)
(*Preprocessing*)


(* ::Subsection::Closed:: *)
(*Initialization*)


(* ::Text:: *)
(*To begin, initialize ChemicalData and set the file location*)


(* ::Input:: *)
(*fileLoc=NotebookDirectory[];*)
(*ChemicalData["All","Preload"];*)
(*ChemicalData["All","Install"];*)
(*RebuildPacletData[];*)


(* ::Subsection::Closed:: *)
(*Downloading the Data*)


(* ::Text:: *)
(*Define a list of properties to be extracted from the ChemicalData[] set. It is more efficient to download the data once than to continually pull data from the server.*)


(* ::Input:: *)
(*molecularProperties={"SMILES",*)
(*					"BondCounts",*)
(*					"VaporizationHeat",*)
(*					"CombustionHeat",*)
(*					"FusionHeat",*)
(*					"FormalCharges",*)
(*					"NetCharge",*)
(*					"PartitionCoefficient",*)
(*					"TopologicalPolarSurfaceArea",*)
(*					"NonStandardIsotopeNumbers",*)
(*					"AtomPositions",*)
(*					"VertexTypes",*)
(*					"BoilingPoint",*)
(*					"MeltingPoint",*)
(*					"MolarMass",*)
(*					"AdjacencyMatrix",*)
(*					"RotatableBondCount",*)
(*					"HBondAcceptorCount",*)
(*					"HBondDonorCount",*)
(*					"BlackStructureDiagram",*)
(*					"Name"};*)


(* ::Text:: *)
(*This cell takes a while: it downloads all of the data requested.*)


(* ::Input:: *)
(*totalSetRaw=RandomSample[ChemicalData[],molecularProperties];//Timing*)


(* ::Text:: *)
(*Now, the downloaded data is parsed into a form that the remainder of the code uses. The format is a list of associations, "chemical names"->{"property"->"value"}.*)


(* ::Input:: *)
(*propertiesExceptName=molecularProperties[[1;;-2]];*)
(*names=totalSetRaw[[;;,-1]];*)
(*totalSetBase=Association[Map[#1-> propertiesExceptName&,names]];*)
(*totalSet=Association[Table[names[[i]]-> Association[Thread[totalSetBase[[names[[i]]]]-> totalSetRaw[[i,;;-2]]]],{i,1,Length[totalSetRaw]}]];*)


(* ::Text:: *)
(*This cell only takes the chemicals with sufficient data for analysis. Not all properties are required (i.e., Heat of Fusion), because very few chemicals have this value. Instead, the data will be further filtered later when needed. Other requirements are that the chemical contains only standard isotopes (to prevent redundancy), contains C, contains more than one type of element, and contains nothing except C,H,O,N.*)


(* ::Input:: *)
(*requiredProperties[A_]:=And[Not[MissingQ[A["SMILES"]]],*)
(*							StringQ[A["SMILES"]],*)
(**)
(*							Not[MissingQ[A["AdjacencyMatrix"]]],*)
(*							ArrayQ[A["AdjacencyMatrix"]],*)
(*							Total[Total[A["AdjacencyMatrix"]]]>0,*)
(**)
(*							Not[MissingQ[A["BoilingPoint"]]],*)
(*							QuantityQ[A["BoilingPoint"]],*)
(**)
(*							Not[MissingQ[A["MolarMass"]]],*)
(*							QuantityQ[A["MolarMass"]],*)
(**)
(*							Not[MissingQ[A["MeltingPoint"]]],*)
(*							QuantityQ[A["MeltingPoint"]],*)
(**)
(*							Not[MissingQ[A["AtomPositions"]]],*)
(*							ListQ[A["AtomPositions"]],*)
(**)
(*							Not[MissingQ[A["HBondDonorCount"]]],*)
(*							IntegerQ[A["HBondDonorCount"]],*)
(**)
(*							Not[MissingQ[A["HBondAcceptorCount"]]],*)
(*							IntegerQ[A["HBondAcceptorCount"]],*)
(**)
(*							Not[MissingQ[A["RotatableBondCount"]]],*)
(*							IntegerQ[A["RotatableBondCount"]],*)
(**)
(*							Not[MissingQ[A["TopologicalPolarSurfaceArea"]]],*)
(*							QuantityQ[A["TopologicalPolarSurfaceArea"]],*)
(**)
(*							Not[MissingQ[A["PartitionCoefficient"]]],*)
(*							NumberQ[A["PartitionCoefficient"]],*)
(**)
(*							Not[MissingQ[A["NetCharge"]]],*)
(*							NumberQ[A["NetCharge"]],*)
(**)
(*							Not[MissingQ[A["FormalCharges"]]],*)
(*							ListQ[A["FormalCharges"]],*)
(**)
(*							Not[MissingQ[A["BondCounts"]]],*)
(**)
(*							Not[MissingQ[A["VertexTypes"]]],*)
(*							SubsetQ[{"C","O","H","N"},DeleteDuplicates[A["VertexTypes"]]],*)
(*							Length[DeleteDuplicates[A["VertexTypes"]]]>1,*)
(*							SubsetQ[A["VertexTypes"],{"C"}],*)
(**)
(*							Not[MissingQ[A["NonStandardIsotopeNumbers"]]],*)
(*							And@@Map[Not[IntegerQ[#]]&,A["NonStandardIsotopeNumbers"]]]*)
(**)
(**)
(*totalSet=Select[totalSet,requiredProperties[#]&];*)


(* ::Text:: *)
(*It is best to save the file occasionally, because some preprocessing steps take many hours to complete. Multiple save files will be created to prevent overwriting data.*)


(* ::Input:: *)
(*tempfile=StringJoin[fileLoc,"totalSetBase.wl"];*)
(*Save[tempfile,totalSet]*)


(* ::Subsection::Closed:: *)
(*Data Analysis*)


(* ::Subsubsection::Closed:: *)
(*Subgraphs*)


(* ::Text:: *)
(*This block of code find unique subgraphs within a chemical structure. Subgraphs are considered unique if they contain a different set of connected non-Hydrogen atoms. For simplicity, only structures with bond "radii" of 1,2,3,and 4 are considered. Bond radius is distance, in number of bonds, between the central atom and the outermost atom of the structure. These structures will be stored as graphs, which are transformed into a canonical adjacency matrix. These matrices, along with a sorted vector of constituent atom types, are hashed into a single value representing the substructure. Multiple chemicals are compared by the counts of each unique substructure. See below for an example.*)


(* ::Input:: *)
(*graphSize={1,2,3,4};*)
(**)
(*heavyVertices[g_,vertexTypes_]:=Select[VertexList[g],vertexTypes[[#]]!="H"&]*)
(*lightVertices[g_,vertexTypes_]:=Select[VertexList[g],vertexTypes[[#]]=="H"&]*)
(**)
(*bondsBetween[i_,j_,g_]:=0/;Equal[i,j]*)
(*bondsBetween[i_,j_,g_]:=With[{vList=VertexList[g]},*)
(*							Length[*)
(*							Cases[*)
(*							EdgeList[g],vList[[i]]<->vList[[j]]*)
(*								]*)
(*								]+*)
(*							Length[*)
(*							Cases[*)
(*							EdgeList[g],vList[[j]]<->vList[[i]]*)
(*								]*)
(*								]*)
(*							]/;Not[Equal[i,j]]*)
(**)
(**)
(*subgraphList[graph_,graphSize_,vertexTypes_]:=Distribute[*)
(*												NeighborhoodGraph[*)
(*												graph,*)
(*												heavyVertices[graph,vertexTypes],*)
(*												graphSize*)
(*												],*)
(*												List];*)
(**)
(*hydrogenSubgraphList[graph_,graphSize_,vertexTypes_]:=*)
(*														Map[*)
(*														Subgraph[*)
(*														graph,*)
(*														ConnectedComponents[*)
(*														Subgraph[*)
(*														graph,*)
(*														{VertexList[#],lightVertices[graph,vertexTypes]}*)
(*														]*)
(*														][[1]]]&,*)
(*														subgraphList[graph,graphSize,vertexTypes]];*)
(**)
(*canonicalAdjM[g_,vertexTypes_]:={*)
(*								With[{*)
(*									sortedList=SortBy[*)
(*												Range[Length[VertexList[g]]],*)
(*												-KatzCentrality[g,0.1][[#]]&]},*)
(*									Table[*)
(*										bondsBetween[i,j,g],*)
(*										{i,sortedList},*)
(*										{j,sortedList}]],*)
(*								With[{*)
(*									sortedList=SortBy[*)
(*												Range[Length[VertexList[g]]],*)
(*												-KatzCentrality[g,0.1][[#]]&]},*)
(*									vertexTypes[[*)
(*											VertexList[g][[sortedList]]*)
(*											]]*)
(*									]*)
(*								}*)
(**)
(*subAdjMList[graph_,graphSize_,vertexTypes_]:=Map[*)
(*												canonicalAdjM[*)
(*													Subgraph[graph,#],*)
(*													vertexTypes] &,*)
(*												DeleteDuplicatesBy[*)
(*													hydrogenSubgraphList[graph,graphSize,vertexTypes],*)
(*													{*)
(*													{Sort[heavyVertices[#,vertexTypes]]},*)
(*													Length[lightVertices[#,vertexTypes]]*)
(*												}&*)
(*												]*)
(*												]*)


(* ::Text:: *)
(*Take 2-Hydroxy-4-Methoxybenzoic Acid, a molecule with a number of recognizable functional groups*)


(* ::Input:: *)
(*ChemicalData["2Hydroxy4MethoxybenzoicAcid"]*)


(* ::Text:: *)
(*Using the analysis described above, the substructures or the graph can be extracted. Some of the structures are recognizable function groups (carbonyl, alcohol, carboxylic acid, ether).*)


(* ::Input:: *)
(*g=AdjacencyGraph[ChemicalData["2Hydroxy4MethoxybenzoicAcid","AdjacencyMatrix"]];*)
(*vl=ChemicalData["2Hydroxy4MethoxybenzoicAcid","VertexTypes"];*)
(*Graph[AdjacencyGraph[#[[1]]],VertexLabels-> Thread[Range[Length[#[[2]]]]-> #[[2]]]]&/@subAdjMList[g,graphSize,vl]*)


(* ::Text:: *)
(*Now, perform the analysis on the total set, and save it into a new file.*)


(* ::Input:: *)
(*totalSetGraphs=Table[*)
(*					AdjacencyGraph[totalSet[[i]]["AdjacencyMatrix"]],*)
(*					{i,1,Length[totalSet]}*)
(*				];*)
(**)
(*hashesTotal=Table[*)
(*			Map[*)
(*			Hash,*)
(*			subAdjMList[totalSetGraphs[[i]],graphSize]*)
(*			],*)
(*		{i,1,Length[totalSetGraphs]}];*)


(* ::Input:: *)
(*names=Keys[totalSet];*)
(*newSubKeys=Flatten[{Keys[totalSet[[1]]],"Hashes"}];*)
(*totalSetBase=Association[Map[#1-> newSubKeys&,names]];*)
(*totalSet=Association[Table[names[[i]]-> Association[Thread[totalSetBase[[names[[i]]]]-> Join[Values[totalSet[[i]]],{hashesTotal[[i]]}]]],{i,1,Length[totalSet]}]];*)
(*tempfile=StringJoin[fileLoc,"totalSetHashes.wl"];*)
(*Save[tempfile,totalSet]*)


(* ::Subsubsection::Closed:: *)
(*Topological Features*)


(* ::Text:: *)
(*A number of topological features for graphs have been defined, which have proven useful for chemical analysis. Below are functions that will be called when calculating these features. Most are self-explanatory. *)


(* ::Input:: *)
(*Clear[fragments];Clear[g]*)
(**)
(*radius["C",4]=76;*)
(*radius["C",3]=73;*)
(*radius["C",2]=69;*)
(*radius["O",x_]=71;*)
(*radius["N",x_]=66;*)
(*radius["H",x_]=31;*)
(**)
(*heavyVertices[g_,vertexTypes_]:=Select[VertexList[g],vertexTypes[[#]]!="H"&]*)
(*lightVertices[g_,vertexTypes_]:=Select[VertexList[g],vertexTypes[[#]]=="H"&]*)
(**)
(*coreElec["C"]=6;coreElec["O"]=8;coreElec["N"]=7;coreElec["H"]=1;*)
(*valElec["C"]=4;valElec["O"]=6;valElec["N"]=5;valElec["H"]=1;*)
(**)
(**)
(*adjacentH[g_,k_]:=Length[Intersection[VertexList[NeighborhoodGraph[g,k]],lightVertices[g]]];*)
(**)
(**)
(*fragments[g_,m_,vl_]:=fragments[g,m,vl]=Select[*)
(*										VertexList/@*)
(*											Select[*)
(*												Subsets[*)
(*													DeleteDuplicates[*)
(*														EdgeList[*)
(*															Subgraph[g,heavyVertices[g,vl]]]],*)
(*												{m}],*)
(*											ConnectedGraphQ[Graph[#]]&],*)
(*										Length[#]==m+1&];*)
(**)
(**)
(**)
(*allFragments[g_,m_,vl_]:=allFragments[g,m,vl]=Select[*)
(*												VertexList/@*)
(*													Select[*)
(*														Subsets[*)
(*															DeleteDuplicates[*)
(*																EdgeList[*)
(*																	Subgraph[g,VertexList[g]]]],*)
(*														{m}],*)
(*													ConnectedGraphQ[Graph[#]]&],*)
(*												Length[#]==m+1&];*)
(**)
(*\[Delta][g_,k_,vl_]:=(valElec[vl[k]] - adjacentH[g,k,vl]) / (coreElec[vl[k]] - valElec[vl[k]] - 1)*)
(**)
(*\[Alpha][g_,vl_]:=\[Alpha][g,vl]=Sum[*)
(*				radius[*)
(*						vl[[i]],*)
(*						DegreeCentrality[g][[i]]*)
(*					]/radius[4,4]-1,*)
(*			{i,heavyVertices[g,vl]}]*)
(**)
(*P[g_,m_,vl_]:=P[g,m,vl]=Length[fragments[g,m,vl]]*)
(**)
(*S[g_]:=S[g]=GraphDistanceMatrix[g];*)


(* ::Text:: *)
(*Below are the topological and constituent feature extractors for the molecules. For more information, see the Codessa PRO list of descriptors.*)


(* ::Input:: *)
(*KierShape[g_,1,vl_]:=(Length[heavyVertices[g,vl]]+\[Alpha][g,vl])  *  (Length[heavyVertices[g,vl]]+\[Alpha][g,vl]-1)^2  *  (P[g,1,vl]+\[Alpha][g,vl])^2//N*)
(*KierShape[g_,2,vl_]:=(Length[heavyVertices[g,vl]]+\[Alpha][g,vl]-1)  *  (Length[heavyVertices[g,vl]]+\[Alpha][g,vl]-2)^2  *  (P[g,2,vl]+\[Alpha][g,vl])^2//N*)
(*KierShape[g_,3,vl_]:=N[(Length[heavyVertices[g,vl]]+\[Alpha][g,vl]-1)  *  (Length[heavyVertices[g,vl]]+\[Alpha][g,vl]-3)^2  *  (P[g,3,vl]+\[Alpha][g,vl])^2]  /;OddQ[Length[heavyVertices[g,vl]]]*)
(*KierShape[g_,3,vl_]:=N[(Length[heavyVertices[g,vl]]+\[Alpha][g,vl]-3)  *  (Length[heavyVertices[g,vl]]+\[Alpha][g,vl]-2)^2  *  (P[g,3,vl]+\[Alpha][g,vl])^2]  /;EvenQ[Length[heavyVertices[g,vl]]]*)
(**)
(*KierFlex[g_,vl_]:=(KierShape[g,1,vl]*KierShape[g,2,vl])/Length[heavyVertices[g,vl]]*)
(**)
(*countArom[g_]:=Length[*)
(*					Select[*)
(*						Map[*)
(*							Count[EdgeList[g],#]&,*)
(*							Map[(#|Reverse[#])&,*)
(*								FindCycle[*)
(*									Graph[DeleteDuplicates[EdgeList[g]]]*)
(*									,Infinity,All]*)
(*								,{2}]*)
(*							,{2}],*)
(*						And[*)
(*							MatchQ[#,{PatternSequence[a_,b_]..}|{PatternSequence[a_,b_]..,a_}],*)
(*							IntegerQ[(Count[#,2]-1)/2]]&*)
(*							]*)
(*						]*)
(**)
(**)
(*count6Arom[g_]:=Length[*)
(*					Select[*)
(*						Map[*)
(*							Count[EdgeList[g],#]&,*)
(*							Map[(#|Reverse[#])&,*)
(*								FindCycle[*)
(*									Graph[*)
(*										DeleteDuplicates[*)
(*										EdgeList[g]]]*)
(*									,Infinity,All]*)
(*								,{2}]*)
(*							,{2}],*)
(*						And[*)
(*							MatchQ[#,{PatternSequence[a_,b_]..}|{PatternSequence[a_,b_]..,a_}],*)
(*							Length[#]==6]&]*)
(*						]*)
(**)
(*countRing[g_]:=Length[*)
(*					FindCycle[*)
(*						Graph[*)
(*							DeleteDuplicates[*)
(*								EdgeList[g]]*)
(*							]*)
(*						,Infinity,All]*)
(*					]*)
(**)
(*edgeCount[g_]:=Length[EdgeList[g]];*)
(*bondCount[g_]:=Length[DeleteDuplicates[EdgeList[g]]];*)
(*singleCount[g_]:=Count[Tally[EdgeList[g]],{_,1}];*)
(*doubleCount[g_]:=Count[Tally[EdgeList[g]],{_,2}];*)
(*tripleCount[g_]:=Count[Tally[EdgeList[g]],{_,3}];*)
(**)
(**)
(*KierHallVCI[g_,m_,vl_]:=Sum[*)
(*			Product[*)
(*				\[Delta][*)
(*					g,*)
(*					fragments[g,m,vl][[i,j]]*)
(*					]^(-0.5)*)
(*				,{j,1,m+1}],*)
(*			{i,1,Length[fragments[g,m,vl]]}];*)
(**)
(*WienerIDX[g_,vl_]:=1/2*Sum[*)
(*				Sum[*)
(*					Length[*)
(*						FindShortestPath[*)
(*							g,*)
(*							heavyVertices[g,vl][[i]],*)
(*							heavyVertices[g,vl][[j]]*)
(*							]*)
(*						]-1,*)
(*				{i,1,Length[heavyVertices[g,vl]]}],*)
(*			{j,1,Length[heavyVertices[g,vl]]}]*)
(**)
(**)
(*BalabonJ[g_]:=1/(Length[EdgeList[g]]-Length[VertexList[g]]+2)**)
(*													Sum[( *)
(*														Total[S[g][[DeleteDuplicates[EdgeList[g]][[i,1]],;;]]]*)
(*														*Total[S[g][[DeleteDuplicates[EdgeList[g]][[i,2]],;;]]])^-0.5,*)
(*													{i,1,Length[DeleteDuplicates[EdgeList[g]]]}]*)
(**)
(*randicMCI[g_,m_,vl_]:=Total[*)
(*				Times[#]^-0.5& @@@ *)
(*					Map[*)
(*						VertexDegree[g,#]&,*)
(*						allFragments[g,m,vl],*)
(*						{2}]*)
(*				]*)


(* ::Input:: *)
(*topoFeaturesTotal=Table[*)
(*With[{g=AdjacencyGraph[totalSet[[i]]["AdjacencyMatrix"]],vl=totalSet[[i]]["VertexTypes"]},*)
(*{KierShape[g,1,vl],*)
(*KierShape[g,2,vl],*)
(*KierShape[g,3,vl],*)
(*KierFlex[g,vl],*)
(*countArom[g],*)
(*KierHallVCI[g,1,vl],*)
(*KierHallVCI[g,2,vl],*)
(*KierHallVCI[g,3,vl],*)
(*KierHallVCI[g,4,vl],*)
(*WienerIDX[g,vl],*)
(*BalabonJ[g],*)
(*randicMCI[g,1,vl],*)
(*randicMCI[g,2,vl],*)
(*randicMCI[g,3,vl],*)
(*countRing[g],*)
(*count6Arom[g],*)
(*edgeCount[g],*)
(*bondCount[g],*)
(*singleCount[g],*)
(*doubleCount[g],*)
(*tripleCount[g]}*)
(*],*)
(*{i,1,Length[totalSet]}];*)


(* ::Input:: *)
(*names=Keys[totalSet];*)
(*newSubKeys=Flatten[{Keys[totalSet[[1]]],"TopoFeatures"}];*)
(*totalSetBase=Association[Map[#1-> newSubKeys&,names]];*)
(*totalSet=Association[Table[names[[i]]-> Association[Thread[totalSetBase[[names[[i]]]]-> Join[Values[totalSet[[i]]],{topoFeaturesTotal[[i]]}]]],{i,1,Length[totalSet]}]];*)
(*tempfile=StringJoin[fileLoc,"totalSetTopo.wl"];*)
(*Save[tempfile,totalSet]*)


(* ::Subsubsection::Closed:: *)
(*Geometric Features*)


(* ::Text:: *)
(*Geometry, including surface area and volume, play an enormous role in physical properties. To analyze the structures, the atomic positions are turned into a surface. Spheres with radii corresponding to the van de Waals radii of the molecules are merged into a single mesh. From there, the region is analyzed, as is the minimum bounding box and the convex hull of the region.*)


(* ::Input:: *)
(*rC=170;rO=152;rN=155;rH=120;*)
(**)
(*atomPosTotal=Table[*)
(*				totalSet[[i]]["AtomPositions"],*)
(*				{i,1,Length[totalSet]}];*)
(**)
(*radiiTotal=Table[*)
(*			totalSet[[i]]["VertexTypes"]/.{"C"-> rC,"H"-> rH,"N"-> rN,"O"-> rO},*)
(*			{i,1,Length[totalSet]}];*)
(**)
(**)
(*rgnTotal=Table[*)
(*		RegionUnion[*)
(*		Table[*)
(*		Ball[*)
(*		atomPosTotal[[j,i]],*)
(*		radiiTotal[[j,i]]*)
(*		],*)
(*		{i,1,Length[atomPosTotal[[j]]]}]*)
(*		],*)
(*		{j,1,Length[totalSet]}];*)
(**)
(*meshTotal=BoundaryDiscretizeRegion/@rgnTotal;*)
(**)
(*meshConvexTotal=ConvexHullMesh[MeshCoordinates[#]]&/@meshTotal;*)
(**)
(*PPListTotal =Table[*)
(*				(List@@BoundingRegion[meshTotal[[i]],"MinOrientedCuboid"])[[2]],*)
(*				{i,1,Length[meshTotal]}];*)


(* ::Text:: *)
(*Once the meshes are generated, the volume, surface area, and SA/V ratio are calculated for each molecule. The length of the bounding box axes are also included.*)


(* ::Input:: *)
(*vMolTotal=Volume/@meshTotal;*)
(*saMolTotal=Area[RegionBoundary[#]]&/@meshTotal;*)
(**)
(*vBoxTotal=Table[*)
(*			Dot[*)
(*			Cross[*)
(*			PPListTotal[[i,1]],*)
(*			PPListTotal[[i,2]]*)
(*				],*)
(*			PPListTotal[[i,3]]*)
(*			],*)
(*			{i,1,Length[PPListTotal]}];*)
(**)
(*saBoxTotal=Table[*)
(*			2*Total[*)
(*			Norm /@ *)
(*			(Cross @@@ Subsets[PPListTotal[[i]],{2}])*)
(*			],*)
(*			{i,1,Length[PPListTotal]}];*)
(**)
(*edgesBoxTotal=Table[*)
(*				Norm/@*)
(*				( *)
(*				(List @@BoundingRegion[meshTotal[[i]],"MinOrientedCuboid"])[[2]]*)
(*				),*)
(*				{i,1,Length[PPListTotal]}];*)
(**)
(*vConvexTotal=Volume/@meshConvexTotal;*)
(*saConvexTotal=Area[RegionBoundary[#]]&/@meshConvexTotal;*)
(**)
(**)
(*geomFeaturesTotal=Map[*)
(*					Flatten,*)
(*					Thread[{vMolTotal,*)
(*							saMolTotal,*)
(*							saMolTotal/vMolTotal,*)
(*							vBoxTotal,*)
(*							saBoxTotal,*)
(*							saBoxTotal/vBoxTotal,*)
(*							edgesBoxTotal,*)
(*							vConvexTotal,*)
(*							saConvexTotal,*)
(*							saConvexTotal/vConvexTotal}*)
(*						]*)
(*					];*)


(* ::Input:: *)
(*names=Keys[totalSet];*)
(*newSubKeys=Flatten[{Keys[totalSet[[1]]],"Geom"}];*)
(*totalSetBase=Association[Map[#1-> newSubKeys&,names]];*)
(*totalSet=Association[Table[names[[i]]-> Association[Thread[totalSetBase[[names[[i]]]]-> Join[Values[totalSet[[i]]],{geomFeaturesTotal[[i]]}]]],{i,1,Length[totalSet]}]];*)
(*tempfile=StringJoin[fileLoc,"totalSetGeom.wl"];*)
(*Save[tempfile,totalSet]*)


(* ::Subsubsection::Closed:: *)
(*Moments of Inertia*)


(* ::Text:: *)
(*Moments of inertia proved valuable in estimating molecular shape. Generally, the relative magnitude of the moments of inertia can be used to separate the molecule into classes: spherical, oblate, or prolate. Rather than simply classify into discrete sets, the moments of inertia were included as features.*)


(* ::Input:: *)
(*mass["C"]=12.0107;*)
(*mass["H"]=1.00794;*)
(*mass["O"]:=15.999;*)
(*mass["N"]=14.0067;*)
(**)
(*intertiaMoments[masses_,positions_]:=Eigenvalues[*)
(*										Total@*)
(*										MapThread[*)
(*										With[*)
(*										{m=#1,x=#2[[1]],y=#2[[2]],z=#2[[3]]},*)
(*										m*{{y^2+z^2,-x*y,-x*z},*)
(*										{-x*y,x^2+z^2,-y*z},*)
(*										{-x*z,-y*z,x^2+y^2}*)
(*										}*)
(*										]&,*)
(*										{masses,positions}]];*)


(* ::Text:: *)
(*The moments of inertia are calculates for each molecule, scaled, and stored.*)


(* ::Input:: *)
(*principalMoments=Table[*)
(*					intertiaMoments[*)
(*						mass/@*)
(*						totalSet[[i]]["VertexTypes"],*)
(*						totalSet[[i]]["AtomPositions"]*)
(*					]/10^6,*)
(*				{i,1,Length[totalSet]}];*)


(* ::Input:: *)
(*names=Keys[totalSet];*)
(*newSubKeys=Flatten[{Keys[totalSet[[1]]],"PrincipalMom"}];*)
(*totalSetBase=Association[Map[#1-> newSubKeys&,names]];*)
(*totalSet=Association[Table[names[[i]]-> Association[Thread[totalSetBase[[names[[i]]]]-> Join[Values[totalSet[[i]]],{principalMoments[[i]]}]]],{i,1,Length[totalSet]}]];*)


(* ::Input:: *)
(*tempfile=StringJoin[fileLoc,"totalSetIntertia.wl"];*)
(*Save[tempfile,totalSet]*)


(* ::Subsubsection::Closed:: *)
(*Bond Counts*)


(* ::Text:: *)
(*The number of bonds (e.g., C-H, N=N) can be extracted from the data. Below, the data output from ChemicalData[] is changed into an easier form to analyze. The output is a length 16 vector with entries corresponding the he counts of bonds of each type/*)


(* ::Input:: *)
(*allBondCounts=Table[totalSet[[i]]["BondCounts"],{i,1,Length[totalSet]}];*)
(*hashKeys=Map[Hash,(Keys[allBondCounts]),{2}];*)
(*hashVals= (Values/@allBondCounts);*)
(*hashedBondCounts=Table[<|Thread[hashKeys[[i]]->hashVals[[i]]]|>,{i,1,Length[allBondCounts]}];*)
(**)
(*uniqueBonds=DeleteDuplicates[Flatten[Map[Hash,(Keys/@allBondCounts),{2}]]];*)
(*totalSetBondCounts=Table[Replace[hashedBondCounts[[i]][#]&/@uniqueBonds,{_?(Not[IntegerQ[#]]&)->0},{1}],{i,1,Length[hashedBondCounts]}];*)


(* ::Input:: *)
(*names=Keys[totalSet];*)
(*newSubKeys=Flatten[{Keys[totalSet[[1]]],"BondTally"}];*)
(*totalSetBase=Association[Map[#1-> newSubKeys&,names]];*)
(*totalSet=Association[Table[names[[i]]-> Association[Thread[totalSetBase[[names[[i]]]]-> Join[Values[totalSet[[i]]],{totalSetBondCounts[[i]]}]]],{i,1,Length[totalSet]}]];*)


(* ::Input:: *)
(*tempfile=StringJoin[fileLoc,"totalSetBonds.wl"];*)
(*Save[tempfile,totalSet]*)


(* ::Subsubsection::Closed:: *)
(*Basic Stereo Chemistry*)


(* ::Text:: *)
(*So far, stereochemistry is not taken into account. Unfortunately, there is little that can be done to fix this, as ChemicalData[] has very little information on stereochemistry. To get a vague idea of stereochemistry, the names are searched for the terms "cis" and "trans", and number of occurrences are recorded. *)


(* ::Input:: *)
(*cisCount=StringCount[#,"cis"]&/@Keys[totalSet];*)
(*transCount=StringCount[#,"trans"]&/@Keys[totalSet];*)


(* ::Input:: *)
(*names=Keys[totalSet];*)
(*newSubKeys=Flatten[{Keys[totalSet[[1]]],"Cis","Trans"}];*)
(*totalSetBase=Association[Map[#1-> newSubKeys&,names]];*)
(*totalSet=Association[Table[names[[i]]-> Association[Thread[totalSetBase[[names[[i]]]]-> Join[Values[totalSet[[i]]],{cisCount[[i]]},{transCount[[i]]}]]],{i,1,Length[totalSet]}]];*)


(* ::Input:: *)
(*tempfile=StringJoin[fileLoc,"totalSetCisTrans.wl"];*)
(*Save[tempfile,totalSet]*)


(* ::Subsubsection::Closed:: *)
(*Atom Tallies*)


(* ::Text:: *)
(*Finally, the counts of each type of atom are recorded.*)


(* ::Input:: *)
(*names=Keys[totalSet];*)
(*newSubKeys=Flatten[{Keys[totalSet[[1]]],"AtomTally"}];*)
(*totalSetBase=Association[Map[#1-> newSubKeys&,names]];*)
(*totalSet=Association[Table[names[[i]]-> Association[Thread[totalSetBase[[names[[i]]]]-> Join[Values[totalSet[[i]]],{atomTallies[[i]]}]]],{i,1,Length[totalSet]}]];*)


(* ::Input:: *)
(*tempfile=StringJoin[fileLoc,"FinalSet.wl"];*)
(*Save[tempfile,totalSet]*)


(* ::Section::Closed:: *)
(*References*)


(* ::Item:: *)
(*"Theory: QSAR+ Descriptors." Accelrys, n.d. Web. 04 July 2017. <http://www.ifm.liu.se/compchem/msi/doc/life/cerius46/qsar/theory_descriptors.html>.*)


(* ::Item:: *)
(*Katritzky, Alan, Mati Karelson, and Ruslan Petrukhin. "CODESSA PRO Classes of Descriptors." CODESSA PRO. N.p., n.d. Web. <http://www.codessa-pro.com/descriptors/index.htm>.*)


(* ::Item:: *)
(*"Molar Enthalpy of Formation of Various Substances." Ohio University, n.d. Web. 04 July 2017. <http://www.ohio.edu/mechanical/thermo/property_tables/combustion/Enth_Formation.html>.*)


(* ::Item:: *)
(*Winter, Mark. "The Periodic Table of the Elements." The Periodic Table of the Elements by WebElements. N.p., n.d. Web. 04 July 2017. <https://www.webelements.com/>.*)


(* ::Item:: *)
(*Lazz\[UAcute]s, Juan A."Neural Network Based on Quantum Chemistry for Predicting Melting Point of Organic Compounds." Chinese Journal of Chemical Physics, vol.22, no.1, 2009, pp.19 - 26.*)


(* ::Item:: *)
(*Rogers, David, and Mathew Hahn. "Extended-Connectivity Fingerprints." Journal of Chemical Information and Modeling, vol. 50, no. 5, 2010, pp. 742.*)
(**)
